from src.notifier import notify
from src.util import get_formatted_subatomic_type


template = """/**
 * THIS FILE WAS AUTOMATICALLY GENERATED BY OTP GEN
 * DO NOT MODIFY
 */
import DatagramIterator from "../../otp/net/DatagramIterator";
import ReadHelper from "../../otp/net/ReadHelper";
{imports}

export default class StructParsing {{
"""


class StructParsingTS:
    notify = notify.new_category("StructParsingTS")

    def __init__(self, dc_loader, out_path):
        self.dcLoader = dc_loader
        self.outPath = out_path
        self.outBuffer = ""

        self._gen_buffer()

    def _gen_buffer(self):
        imports = ""
        static_out = ""

        for name, dc_class in self.dcLoader.dclasses_by_name.items():
            if not dc_class.isStruct():
                continue

            imports += f'import {name} from "../dc/{name}";\n'
            static_out += (
                f"\tpublic static get{name}(di: DatagramIterator): {name} {{\n"
            )
            static_out += f"\t\tconst obj = new {name}();\n"

            for i in range(dc_class.get_num_fields()):
                field = dc_class.get_field(i)
                dc_parameter = field.asParameter()
                if not dc_parameter:
                    self.notify.warning(
                        f"Got non parameter field in struct: {name} - {field.getName()}"
                    )
                    continue

                dc_param_simple = dc_parameter.asSimpleParameter()
                dc_param_array = dc_parameter.asArrayParameter()

                if dc_param_simple:
                    static_out += f"\t\tobj.{field.getName()} = di.get{get_formatted_subatomic_type(dc_param_simple.getType())}();\n"
                elif dc_param_array:
                    static_out += f"\t\tobj.{field.getName()} = ReadHelper.readArrayStatic(di, () => {{\n"

                    # TODO: Can we have multi-dimensional arrays?
                    elem_param_simple = (
                        dc_param_array.getElementType().asSimpleParameter()
                    )
                    elem_param_class = (
                        dc_param_array.getElementType().asClassParameter()
                    )

                    if elem_param_simple:
                        static_out += f"\t\t\treturn di.get{get_formatted_subatomic_type(elem_param_simple.getType())}();\n"
                    elif elem_param_class:
                        static_out += f"\t\t\treturn StructParsing.get{elem_param_class.getClass().getName()}(di);\n"

                    static_out += "\t\t});\n"

            static_out += "\t\treturn obj;\n"
            static_out += "\t}\n\n"

        if imports:
            # Trim off newline.
            imports = imports[:-1]

        self.outBuffer = template.format(imports=imports)
        self.outBuffer += static_out
        self.outBuffer += "\n}"

    def write(self):
        if not self.outBuffer:
            return

        with open(self.outPath / "StructParsing.ts", "w") as out_file:
            out_file.write(self.outBuffer)
