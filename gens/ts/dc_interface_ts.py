from src.notifier import notify
from gens.ts.util_ts import get_ts_type_for_subatomic_type


struct_template = """/**
 * THIS FILE WAS AUTOMATICALLY GENERATED BY OTP GEN
 * DO NOT MODIFY
 */
{imports}
export default class {className} {{
{fields}
}}
"""

class_template = """/**
 * THIS FILE WAS AUTOMATICALLY GENERATED BY OTP GEN
 * DO NOT MODIFY
 */
{imports}
export default interface I{className}{extends} {{
{fields}
}}
"""


class DCInterfaceTS:
    notify = notify.new_category("DCInterfaceTS")

    def __init__(self, name, dclass, out_path):
        self.name = name
        self.dclass = dclass
        self.outPath = out_path
        self.outName = ""
        self.outBuffer = ""

        if dclass.isStruct():
            self._gen_struct_buffer()
        else:
            self._gen_class_buffer()

    def _gen_struct_buffer(self):
        self.outName = f"{self.name}.ts"

        imports = ""
        existing_imports = set()

        fields = ""
        for i in range(self.dclass.get_num_fields()):
            field = self.dclass.get_field(i)
            dc_parameter = field.asParameter()
            if not dc_parameter:
                self.notify.warning(
                    f"Got non parameter field in struct: {self.name} - {field.getName()}"
                )
                continue

            fields += f"\tpublic {field.getName()}!: "

            dc_param_simple = dc_parameter.asSimpleParameter()
            dc_param_class = dc_parameter.asClassParameter()
            dc_param_array = dc_parameter.asArrayParameter()

            if dc_param_simple:
                # We have a simple generic type parameter.
                fields += (
                    f"{get_ts_type_for_subatomic_type(dc_param_simple.getType())};\n"
                )
            elif dc_param_class:
                # We have a singular class parameter.
                class_name = dc_param_class.getClass().getName()
                if class_name not in existing_imports:
                    imports += f'import {class_name} from "./{class_name}";\n'
                    existing_imports.add(class_name)

                fields += f"{class_name};\n"
            else:
                # We have an array of *something*.
                elem_param_simple = dc_param_array.getElementType().asSimpleParameter()
                elem_param_class = dc_param_array.getElementType().asClassParameter()

                if elem_param_class:
                    # We have an array of classes.
                    class_name = elem_param_class.getClass().getName()
                    if class_name not in existing_imports:
                        imports += f'import {class_name} from "./{class_name}";\n'
                        existing_imports.add(class_name)

                    fields += f"{class_name}[];\n"
                else:
                    # We have an array of generic types.
                    fields += f"{get_ts_type_for_subatomic_type(elem_param_simple.getType())}[];\n"

        if fields:
            # Chop off our last char (\n)
            fields = fields[:-1]

        self.outBuffer = struct_template.format(
            className=self.name, imports=imports, fields=fields
        )

    def _gen_class_buffer(self):
        self.outName = f"I{self.name}.ts"

        imports = ""
        extends = ""
        existing_imports = set()

        if self.dclass.get_num_parents():
            # This distributed class inherits from at least one parent.
            extends = " extends "
            for i in range(self.dclass.get_num_parents()):
                parent = self.dclass.get_parent(i)
                name = f"I{parent.getName()}"  # Prepend with an 'I'
                imports += f'import {name} from "./{name}";\n'
                extends += f"{name}, "

            # Chop off our last two chars (, )
            extends = extends[:-2]

        fields = ""
        for i in range(self.dclass.get_num_fields()):
            field = self.dclass.get_field(i)
            atomic_field = field.asAtomicField()
            # TODO: DC parameters.
            if not atomic_field:
                self.notify.warning(f"Got non atomic field {self.name}")
                continue

            params = ""
            arg_index = 1
            for k in range(atomic_field.getNumElements()):
                elem = atomic_field.getElement(k)
                elem_class = elem.asClassParameter()
                elem_simple = elem.asSimpleParameter()
                elem_array = elem.asArrayParameter()

                if elem_class:
                    # This is (always?) a struct arg.
                    elem_dc_class = elem_class.getClass()
                    if not elem_dc_class.isStruct():
                        self.notify.warning(
                            f"Got non-struct class as field param: {self.name} - {field.getName()}"
                        )
                        continue

                    class_name = elem_dc_class.getName()
                    if class_name not in existing_imports:
                        imports += f'import {class_name} from "./{class_name}";\n'
                        existing_imports.add(class_name)

                    params += f"arg{arg_index}: {class_name}, "

                elif elem_simple:
                    elem_type = elem_simple.getType()
                    params += (
                        f"arg{arg_index}: {get_ts_type_for_subatomic_type(elem_type)}, "
                    )

                elif elem_array:
                    elem_param_simple = elem_array.getElementType().asSimpleParameter()
                    elem_param_class = elem_array.getElementType().asClassParameter()

                    if elem_param_class:
                        # We have an array of classes.
                        class_name = elem_param_class.getClass().getName()
                        if class_name not in existing_imports:
                            imports += f'import {class_name} from "./{class_name}";\n'
                            existing_imports.add(class_name)

                        params += f"arg{arg_index}: {class_name}[], "
                    else:
                        # We have an array of generic types.
                        params += f"arg{arg_index}: {get_ts_type_for_subatomic_type(elem_param_simple.getType())}[], "

                arg_index += 1

            if params:
                # Slice off last two chars (, )
                params = params[:-2]

            fields += f"\t{field.getName()}({params}): void;\n"

        if fields:
            # Chop off our last char (\n)
            fields = fields[:-1]

        self.outBuffer = class_template.format(
            className=self.name, imports=imports, extends=extends, fields=fields
        )

    def write(self):
        if not self.outName or not self.outBuffer:
            return

        with open(self.outPath / self.outName, "w") as out_file:
            out_file.write(self.outBuffer)
