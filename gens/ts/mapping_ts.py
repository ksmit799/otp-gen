# TODO: Can we use a better generic for functions and classes?
template = """/**
 * THIS FILE WAS AUTOMATICALLY GENERATED BY OTP GEN
 * DO NOT MODIFY
 */
import ObjectInitialization from "./ObjectInitialization";
import FunctionParsing from "./FunctionParsing";
{imports}

export default class DCMapping {{
    private static id2class: {{[id: number]: any}} = {{}};
    private static id2fn: {{[id: number]: any}} = {{}};
    private static fnid2name: {{[id: number]: string}} = {{}};
    private static fnid2clsname: {{[id: number]: string}} = {{}};
    private static cls2rmccls: {{[name: string]: any}} = {{}};
    private static cls2owninitfn: {{[name: string]: any}} = {{}};
    private static cls2initfn: {{[name: string]: any}} = {{}};
    
    public static getDCVersion(): number {{
        return {dcHash};
    }}
    
    public static getClasses(): string[] {{
        return Object.keys(DCMapping.id2class);
    }}
    
    public static getClassForId(id: number): any {{
        return DCMapping.id2class[id];
    }}
    
    public static getFunctionForId(id: number): any {{
        return DCMapping.id2fn[id];
    }}
    
    public static getFunctionNameForId(id: number): string {{
        return DCMapping.fnid2name[id];
    }}
    
    public static getClassNameForFunctionId(id: number): string {{
        return DCMapping.fnid2clsname[id];
    }}
    
    public static getRemoteInterface(clsName: string): any {{
        return DCMapping.cls2rmccls[clsName];
    }}
    
    public static getOwnerInitFunction(clsName: string): any {{
        return DCMapping.cls2owninitfn[clsName];
    }}
    
    public static getInitFunction(clsName: string): any {{
        return DCMapping.cls2initfn[clsName];
    }}
    
    static {{
"""


class MappingTS:
    def __init__(self, dc_loader, out_path):
        self.dcLoader = dc_loader
        self.outPath = out_path
        self.outBuffer = ""

        self._gen_buffer()

    def _gen_buffer(self):
        imports = ""
        static_out = ""
        for class_id in self.dcLoader.dclasses_by_number:
            dc_class = self.dcLoader.dclasses_by_number[class_id]
            if dc_class.isStruct():
                continue

            class_name = dc_class.getName()

            # Build class id to class name.
            static_out += f'\t\tthis.id2class[{class_id}] = "{class_name}";\n'

            # Build class name to remote.
            imports += f'import R{class_name} from "../remote/R{class_name}";\n'
            static_out += f'\t\tthis.cls2rmccls["{class_name}"] = R{class_name};\n'

            # Build function mapping.
            for i in range(dc_class.get_num_fields()):
                field = dc_class.get_field(i)
                static_out += f"\t\tthis.id2fn[{field.getNumber()}] = FunctionParsing.call_{class_name}_{field.getName()};\n"
                static_out += (
                    f'\t\tthis.fnid2name[{field.getNumber()}] = "{field.getName()}";\n'
                )
                static_out += f"\t\tthis.fnid2clsname[{field.getNumber()}] = this.id2class[{class_id}];\n"

            static_out += f'\t\tthis.cls2initfn["{class_name}"] = ObjectInitialization.init{class_name};\n'

        if imports:
            # Trim off newline.
            imports = imports[:-1]

        self.outBuffer = template.format(
            dcHash=self.dcLoader.hash_value, imports=imports
        )
        self.outBuffer += static_out
        self.outBuffer += "\t}\n}"

    def write(self):
        with open(self.outPath / "DCMapping.ts", "w") as out_file:
            out_file.write(self.outBuffer)
