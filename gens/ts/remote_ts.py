from src.notifier import notify
from gens.ts.util_ts import get_ts_type_for_subatomic_type
from src.util import get_formatted_subatomic_type


template = """/**
 * THIS FILE WAS AUTOMATICALLY GENERATED BY OTP GEN
 * DO NOT MODIFY
 */
import RemoteBase from "../../otp/dc/RemoteBase";
{imports}
export default class R{className} extends RemoteBase implements {implements} {{
{fields}
}}
"""


class RemoteTS:
    notify = notify.new_category("RemoteInterfaceTS")

    def __init__(self, name, dclass, out_path):
        self.name = name
        self.dclass = dclass
        self.outPath = out_path
        self.outName = ""
        self.outBuffer = ""

        self._gen_buffer()

    def _gen_buffer(self):
        self.outName = f"R{self.name}.ts"

        name = f"IR{self.name}"  # Prepend with an 'IR'
        imports = f'import {name} from "../iremote/{name}";\n'
        existing_imports = set()

        fields = ""
        for i in range(self.dclass.get_num_inherited_fields()):
            # We implement parent fields here as well.
            field = self.dclass.get_inherited_field(i)
            if not field.isClsend() and not field.isOwnsend():
                # Skip fields that aren't sendable.
                continue

            atomic_field = field.asAtomicField()
            if not atomic_field:
                continue

            params = ""
            packing = ""
            arg_index = 1
            for k in range(atomic_field.getNumElements()):
                elem = atomic_field.getElement(k)
                elem_class = elem.asClassParameter()
                elem_simple = elem.asSimpleParameter()
                elem_array = elem.asArrayParameter()

                # TODO: We need to do packing for the rest of this.

                if elem_class:
                    # This is (always?) a struct arg.
                    elem_dc_class = elem_class.getClass()
                    if not elem_dc_class.isStruct():
                        self.notify.warning(
                            f"Got non-struct class as field param: {self.name} - {field.getName()}"
                        )
                        continue

                    class_name = elem_dc_class.getName()
                    if class_name not in existing_imports:
                        imports += f'import {class_name} from "../dc/{class_name}";\n'
                        existing_imports.add(class_name)

                    params += f"arg{arg_index}: {class_name}, "

                elif elem_simple:
                    elem_type = elem_simple.getType()
                    params += (
                        f"arg{arg_index}: {get_ts_type_for_subatomic_type(elem_type)}, "
                    )
                    packing += f"\t\tdg.add{get_formatted_subatomic_type(elem_type)}(arg{arg_index});\n"

                elif elem_array:
                    elem_param_simple = elem_array.getElementType().asSimpleParameter()
                    elem_param_class = elem_array.getElementType().asClassParameter()

                    if elem_param_class:
                        # We have an array of classes.
                        class_name = elem_param_class.getClass().getName()
                        if class_name not in existing_imports:
                            imports += (
                                f'import {class_name} from "../dc/{class_name}";\n'
                            )
                            existing_imports.add(class_name)

                        params += f"arg{arg_index}: {elem_param_class.getClass().getName()}[], "
                    else:
                        # We have an array of generic types.
                        params += f"arg{arg_index}: {get_ts_type_for_subatomic_type(elem_param_simple.getType())}[], "

                arg_index += 1

            if params:
                # Slice off last two chars (, )
                params = params[:-2]

            fields += f"\tpublic {field.getName()}({params}) {{\n"
            fields += "\t\tconst dg = this.getPacker();\n"
            fields += "\t\tdg.addUint32(this.doId);\n"
            fields += f"\t\tdg.addUint16({field.getNumber()});\n"
            fields += packing
            fields += "\t\tthis.sendUpdate(dg);\n"
            fields += "\t}\n\n"

        if fields:
            # Chop off our last char (\n)
            fields = fields[:-1]

        self.outBuffer = template.format(
            className=self.name, imports=imports, implements=name, fields=fields
        )

    def write(self):
        if not self.outName or not self.outBuffer:
            return

        with open(self.outPath / self.outName, "w") as out_file:
            out_file.write(self.outBuffer)
