from src.notifier import notify
from src.util import get_formatted_subatomic_type


template = """/**
 * THIS FILE WAS AUTOMATICALLY GENERATED BY OTP GEN
 * DO NOT MODIFY
 */
import StructParsing from "../fn/StructParsing";
import DatagramIterator from "../../otp/net/DatagramIterator";
{imports}

export default class FunctionParsing {{
"""


class FunctionParsingTS:
    notify = notify.new_category("FunctionParsingTS")

    def __init__(self, dc_loader, out_path):
        self.dcLoader = dc_loader
        self.outPath = out_path
        self.outBuffer = ""

        self._gen_buffer()

    def _gen_buffer(self):
        imports = ""
        static_out = ""

        for name, dc_class in self.dcLoader.dclasses_by_name.items():
            if dc_class.isStruct():
                continue

            imports += f'import I{name} from "../dc/I{name}";\n'

            for i in range(dc_class.get_num_fields()):
                field = dc_class.get_field(i)
                static_out += f"\tpublic static call_{name}_{field.getName()}(dc_interface: I{name}, di: DatagramIterator): void {{\n"

                molecular_field = field.asMolecularField()
                atomic_field = field.asAtomicField()
                dc_parameter = field.asParameter()

                if molecular_field:
                    # We have a molecular field composed of fields.
                    for k in range(molecular_field.getNumAtomics()):
                        atomic_field = molecular_field.getAtomic(k)
                        static_out += f"\t\tFunctionParsing.call_{name}_{atomic_field.getName()}(dc_interface, di);\n"

                elif atomic_field:
                    # We have an atomic field.
                    params = ""
                    for k in range(atomic_field.getNumElements()):
                        # TODO: Handle modulus and divisor elements.
                        elem = atomic_field.getElement(k)
                        elem_class = elem.asClassParameter()
                        elem_simple = elem.asSimpleParameter()
                        elem_array = elem.asArrayParameter()

                        if elem_class:
                            # This is (always?) a struct arg.
                            elem_dc_class = elem_class.getClass()
                            if not elem_dc_class.isStruct():
                                self.notify.warning(
                                    f"Got non-struct class as field param: {name} - {elem_dc_class.getName()}"
                                )
                                continue

                            params += (
                                f"StructParsing.get{elem_dc_class.getName()}(di), "
                            )

                        if elem_simple:
                            elem_type = elem_simple.getType()
                            params += (
                                f"di.get{get_formatted_subatomic_type(elem_type)}(), "
                            )

                        elif elem_array:
                            # TODO: Handle array elements.
                            pass

                    if params:
                        # Cut off the last two chars (, )
                        params = params[:-2]

                    static_out += f"\t\tdc_interface.{field.getName()}({params});\n"

                elif dc_parameter:
                    # We have a simple parameter defined.
                    # E.g. uint32 MyField[];
                    elem_simple = dc_parameter.asSimpleParameter()
                    elem_array = dc_parameter.asArrayParameter()

                    if elem_simple:
                        elem_type = elem_simple.getType()
                        static_out += f"\t\tdc_interface.{field.getName()}(di.get{get_formatted_subatomic_type(elem_type)}());\n"
                    else:
                        pass

                else:
                    # Can this even happen?
                    self.notify.error(
                        f"Failed to parse field {field.getName()}, unknown field type!"
                    )

                static_out += "\t}\n\n"

        if imports:
            # Trim off newline.
            imports = imports[:-1]

        self.outBuffer = template.format(imports=imports)
        self.outBuffer += static_out
        self.outBuffer += "\n}"

    def write(self):
        if not self.outBuffer:
            return

        with open(self.outPath / "FunctionParsing.ts", "w") as out_file:
            out_file.write(self.outBuffer)
